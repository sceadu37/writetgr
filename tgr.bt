//------------------------------------------------
//--- 010 Editor v14.0 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

// This Template will work with most TGRs, with or without a palette

LittleEndian();
BitfieldDisablePadding();

typedef struct {
    uint16 ulx;
    uint16 uly;
    uint16 lrx;
    uint16 lry;   
    uint32 offset;
} FRAME_SIZE;

// Represents an 'immediate color' pixel (16 bits representing color)
typedef struct {
    LittleEndian();
    int blue : 5;
    int green : 6;
    int red : 5;
} IMM_PIXEL <optimize=false>;

// Represents an 'indexed color' pixel (8 bits representing palette index)   
typedef struct {
    ubyte index;
} IND_PIXEL;

// Represents two 'player color' pixels, packed into one byte. 
// Perform (pixelN << 1) | 1 to calculate the actual index value
typedef struct {
    LittleEndian();
    int pixel1 : 4;
    int pixel2 : 4;
} PLYR_PIXEL <optimize=false>;

typedef struct {
    BigEndian();
    //local uchar run_header = ReadUByte() >> 5;
    switch(ReadUByte() >> 5) {
        case 0b000:     // Transparent spacing pixels
            int run_type : 3;
            int ct_transparent_pixels : 5;
            break;
        case 0b001:     // Run length encoded run of pixels
            int run_type : 3;
            int run_length : 5;
            if (hedr.bit_depth == 8) {
                IND_PIXEL ind_pixel;
            } else {
                IMM_PIXEL pixel;
            }
            break;
        case 0b010:     // Unencoded run of pixels
            int run_type : 3;
            int run_length : 5;
            if (hedr.bit_depth == 8) {
                IND_PIXEL ind_pixels[run_length];
            } else {
                IMM_PIXEL pixels[run_length];
            }
            break;
        /*case 0b100:     // need to figure out what this is
            int run_type : 3;
            int player_color : 5;
            break;*/
        case 0b110:     // One Player Color pixel
            int run_type : 3;
            int player_color : 5;
            break;
        case 0b111:     // Run Length encoded run of player color pixels
            int run_type : 3;
            int run_length : 5;
            PLYR_PIXEL player_pixels[(run_length + 1) >> 1];  // Since each byte holds 2 pixels, divide taking the ceiling 
            break;
        default:
            ubyte unknown_flag;
            break;
    }
} RUN;

// LINE
typedef struct {
    // line_length is used as a duplicate array to grab 2 bytes 
    // if the line starts 8X, and to just grab one otherwise
    local int ct_header_bytes = 3;
    
    ubyte line_length;
    local int total_line_length = line_length;
    if ((line_length >> 7) == 1) {  
        ubyte line_length; // length of line in bytes, including header
        total_line_length = ((line_length[0] & 0b01111111) << 8) | line_length[1];  // combines both bytes and strips the flag bit
        ct_header_bytes += 1;
    }
    
    ubyte offset;
    local int total_offset = offset;
    if ((offset >> 7) == 1) {  
        ubyte offset; // offset to start of line data, if there are transparent/padding pixels
        total_offset = ((offset[0] & 0b01111111) << 8) | offset[1];  // combines both bytes and strips the flag bit
        ct_header_bytes += 1;
    }
    
    ubyte ct_pixels;
    local int total_ct_pixels = ct_pixels;
    if ((ct_pixels >> 7) == 1) {  
        ubyte ct_pixels; // number of pixels in line
        total_ct_pixels = ((ct_pixels[0] & 0b01111111) << 8) | ct_pixels[1];  // combines both bytes and strips the flag bit
        ct_header_bytes += 1;
    }
    
    local int bytes_used = ct_header_bytes;
    while (bytes_used < total_line_length) {
        RUN run;
        bytes_used += sizeof(run);
    }
    
    
    
    //ubyte line_data[total_line_length - ct_header_bytes]; // (-ct_header_bytes) to account for size of header
} LINE <optimize=false>;


typedef struct {
    char chunk_name[4];
    BigEndian();
    uint32 chunk_length; //distance from end of chunk_length to next FRAM
    LittleEndian();
    local int bytes_used = 0;
    while (bytes_used < chunk_length) {
        if (chunk_length - bytes_used < 4) {
            ubyte padding[chunk_length - bytes_used];
            bytes_used += sizeof(padding);
        } else {
            LINE line;
            bytes_used += sizeof(line);
        }
    }
} FRAM <optimize=false>;

typedef struct {
    char chunk_name[4];
    BigEndian();
    uint32 chunk_length;
    LittleEndian();
    uint16 palette_size;
    ubyte unknown[2];  // Palette size can only be 256, so these bytes are for something else
    IMM_PIXEL pixels[palette_size] <optimize=false>;
} PALT;


struct FORM {
    char chunk_name[4];  // Always FORM
    BigEndian();
    int32 length;  //length in bytes from start of HEDR to end of file
    LittleEndian();
    char file_type[4];  // Always TGAR
} form;

struct HEDR {
    char chunk_name[4];
    BigEndian();
    uint32 chunk_length;
    LittleEndian();
    uint32 version;
    uint16 frame_count;
    ubyte bit_depth;
    ubyte unknown0;
    uint16 index_mode;
    uint16 offset_flag;
    
    struct SIZE {
        uint16 x;
        uint16 y;
    } size;
    
    struct HOTSPOT {
        uint16 x;
        uint16 y;
    } hotspot;
    
    struct BOUNDING_BOX {
        uint16 x_min;
        uint16 y_min;
        uint16 x_max;
        uint16 y_max;
    } bounding_box;
    
    byte unknown1[8]; // seems to contain max frame size
    
    uint32 offset_palette;  // number of bytes from start of file to begining of palette_size (9th byte of PALT)
    
    FRAME_SIZE frame_sizes[frame_count];
    
} hedr;

byte unknown2[(hedr.chunk_length + 8) - sizeof(hedr)];

if (hedr.bit_depth == 8) {
    PALT palt;
}

FRAM frames[hedr.frame_count];